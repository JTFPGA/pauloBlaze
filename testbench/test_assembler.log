KCPSM6 Assembler log file for program 'Z:\home\pgenssler\pauloBlaze\testbench\test_assembler.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 30 Sep 2015
Assembly timestamp: 13:09:54

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 303 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 195
Memory locations available: 3901


Assembly listing

 Addr Code                   Instruction

 000                         CONSTANT A_port, 00
 000                         CONSTANT B_port, 01
 000                         CONSTANT C_port, 02
 000                         CONSTANT D_port, 03
 000                         CONSTANT W_port, 01
 000                         CONSTANT X_port, 02
 000                         CONSTANT Y_port, 04
 000                         CONSTANT Z_port, 08
 000                  start: 
 000  28001                  ENABLE INTERRUPT
 001  14F80                  HWBUILD sF
 002  22003                  JUMP 003[test_star]          ; change to test_pc to test under/overflow
 003              test_star: 
 003  01001                  LOAD s0, 01
 004  16100                  STAR s1, s0
 005  37001                  REGBANK B
 006  1D101                  COMPARE s1, 01
 007  360BD                  JUMP NZ, 0BD[error]
 008  37000                  REGBANK A
 009  2200A                  JUMP 00A[test_add]
 00A               test_add: 
 00A  01001                  LOAD s0, 01
 00B  11004                  ADD s0, 04
 00C  1D005                  COMPARE s0, 05               ; check simple add, 1 + 4 = 5
 00D  360BD                  JUMP NZ, 0BD[error]          ; 0 means it's equal
 00E  01010                  LOAD s0, 10
 00F  0110C                  LOAD s1, 0C
 010  10010                  ADD s0, s1
 011  1D01C                  COMPARE s0, 1C               ; check 2 register add, 0x10 + 0x0C = 0x1C
 012  360BD                  JUMP NZ, 0BD[error]
 013  01005                  LOAD s0, 05
 014  110FB                  ADD s0, FB
 015  3E0BD                  JUMP NC, 0BD[error]          ; check overflow = carry, 5 + 251 = 0 + carry
 016  11001                  ADD s0, 01
 017  1D001                  COMPARE s0, 01
 018  360BD                  JUMP NZ, 0BD[error]
 019  01000                  LOAD s0, 00
 01A  11000                  ADD s0, 00
 01B  360BD                  JUMP NZ, 0BD[error]          ; check for zero flag
 01C  2201D                  JUMP 01D[test_add_carry]
 01D         test_add_carry: 
 01D  010FF                  LOAD s0, FF
 01E  11001                  ADD s0, 01                   ; s0 = 0, carry set
 01F  13001                  ADDCY s0, 01                 ; s0 = s0 + 1 + carry(1)
 020  1D002                  COMPARE s0, 02
 021  360BD                  JUMP NZ, 0BD[error]          ; s0 is not 2
 022  010FF                  LOAD s0, FF
 023  01101                  LOAD s1, 01
 024  10010                  ADD s0, s1                   ; s0 = 0, carry set
 025  12010                  ADDCY s0, s1                 ; s0 = s0 + s1(1) + carry(1)
 026  1D002                  COMPARE s0, 02
 027  360BD                  JUMP NZ, 0BD[error]
 028  22029                  JUMP 029[test_sub]
 029               test_sub: 
 029  0100A                  LOAD s0, 0A
 02A  1900A                  SUB s0, 0A
 02B  360BD                  JUMP NZ, 0BD[error]          ; s0 is supposed to be 0
 02C  010AB                  LOAD s0, AB
 02D  0110B                  LOAD s1, 0B
 02E  18010                  SUB s0, s1                   ; s0 = s0(AB) - s1(0B) = A0
 02F  1D0A0                  COMPARE s0, A0
 030  360BD                  JUMP NZ, 0BD[error]
 031  22032                  JUMP 032[test_sub_carry]
 032         test_sub_carry: 
 032  01000                  LOAD s0, 00
 033  19001                  SUB s0, 01                   ; s0 = 255, carry set
 034  3E0BD                  JUMP NC, 0BD[error]
 035  1B0FE                  SUBCY s0, FE                 ; s0 = s0(255) - FE - carry(1) = 0
 036  360BD                  JUMP NZ, 0BD[error]
 037  01000                  LOAD s0, 00
 038  19001                  SUB s0, 01
 039  0110A                  LOAD s1, 0A
 03A  1A010                  SUBCY s0, s1                 ; s0 = s0(255) - s1(10) - carry(1) = 244
 03B  1D0F4                  COMPARE s0, F4
 03C  360BD                  JUMP NZ, 0BD[error]
 03D  2203E                  JUMP 03E[test_logic]
 03E             test_logic: 
 03E  010CA                  LOAD s0, CA
 03F  03053                  AND s0, 53
 040  1D042                  COMPARE s0, 42               ; CA and 53 = 42!! (but it's just a hex 42)
 041  360BD                  JUMP NZ, 0BD[error]
 042  010CA                  LOAD s0, CA
 043  01114                  LOAD s1, 14
 044  02010                  AND s0, s1                   ; CA and 14 = 0
 045  360BD                  JUMP NZ, 0BD[error]
 046  010FF                  LOAD s0, FF
 047  11101                  ADD s1, 01                   ; carry set
 048  03001                  AND s0, 01
 049  3A0BD                  JUMP C, 0BD[error]           ; carry was not cleared
 04A  010CA                  LOAD s0, CA                  ; -- testing or --
 04B  05053                  OR s0, 53
 04C  1D0DB                  COMPARE s0, DB               ; CA or 53 = DB
 04D  360BD                  JUMP NZ, 0BD[error]
 04E  010F0                  LOAD s0, F0
 04F  0110F                  LOAD s1, 0F
 050  04010                  OR s0, s1                    ; F0 or 0F = 0
 051  320BD                  JUMP Z, 0BD[error]
 052  010FF                  LOAD s0, FF
 053  11101                  ADD s1, 01                   ; carry set
 054  05001                  OR s0, 01
 055  3A0BD                  JUMP C, 0BD[error]           ; carry was not cleared
 056  010CA                  LOAD s0, CA                  ; -- testing xor --
 057  07053                  XOR s0, 53
 058  1D099                  COMPARE s0, 99               ; CA xor 53 = 99
 059  360BD                  JUMP NZ, 0BD[error]
 05A  010F0                  LOAD s0, F0
 05B  011F0                  LOAD s1, F0
 05C  06010                  XOR s0, s1                   ; F0 or F0 = 0
 05D  360BD                  JUMP NZ, 0BD[error]
 05E  010FF                  LOAD s0, FF
 05F  11101                  ADD s1, 01                   ; carry set
 060  07001                  XOR s0, 01
 061  3A0BD                  JUMP C, 0BD[error]           ; carry was not cleared
 062  22063                  JUMP 063[test_shift]
 063             test_shift: 
 063  0107F                  LOAD s0, 7F
 064  14007                  SL1 s0
 065  3A0BD                  JUMP C, 0BD[error]
 066  1D0FF                  COMPARE s0, FF
 067  360BD                  JUMP NZ, 0BD[error]
 068  01080                  LOAD s0, 80
 069  14006                  SL0 s0
 06A  360BD                  JUMP NZ, 0BD[error]
 06B  14000                  SLA s0
 06C  1D001                  COMPARE s0, 01
 06D  360BD                  JUMP NZ, 0BD[error]
 06E  01011                  LOAD s0, 11
 06F  14002                  RL s0
 070  1D022                  COMPARE s0, 22
 071  360BD                  JUMP NZ, 0BD[error]
 072  01081                  LOAD s0, 81
 073  14004                  SLX s0
 074  1D003                  COMPARE s0, 03
 075  360BD                  JUMP NZ, 0BD[error]
 076  010FE                  LOAD s0, FE
 077  1400F                  SR1 s0
 078  3A0BD                  JUMP C, 0BD[error]
 079  1D0FF                  COMPARE s0, FF
 07A  360BD                  JUMP NZ, 0BD[error]
 07B  01001                  LOAD s0, 01
 07C  1400E                  SR0 s0
 07D  360BD                  JUMP NZ, 0BD[error]
 07E  14008                  SRA s0
 07F  1D080                  COMPARE s0, 80
 080  360BD                  JUMP NZ, 0BD[error]
 081  01022                  LOAD s0, 22
 082  1400C                  RR s0
 083  1D011                  COMPARE s0, 11
 084  360BD                  JUMP NZ, 0BD[error]
 085  01081                  LOAD s0, 81
 086  1400A                  SRX s0
 087  1D0C0                  COMPARE s0, C0
 088  360BD                  JUMP NZ, 0BD[error]
 089  2208A                  JUMP 08A[test_io]
 08A                test_io: 
 08A  01001                  LOAD s0, 01
 08B  01102                  LOAD s1, 02
 08C  00210                  LOAD s2, s1
 08D  0141E                  LOAD s4, 1E
 08E  2C020                  OUTPUT s0, (s2)              ; output value 01 on port 02
 08F  2D103                  OUTPUT s1, 03                ; output value 02 on port 03
 090  2B034                  OUTPUTK 03, 4                ; output value 03 on port 04
 091  09305                  INPUT s3, 05                 ; read value on port id 05 into s3
 092  08140                  INPUT s1, (s4)               ; read value on port id 1E into s1
 093  2D110                  OUTPUT s1, 10                ; output read value on port id 10
 094  22095                  JUMP 095[test_spm]
 095               test_spm: 
 095  01012                  LOAD s0, 12
 096  0110A                  LOAD s1, 0A
 097  012FF                  LOAD s2, FF
 098  2E010                  STORE s0, (s1)               ; write 12 into addr 0A
 099  2F1C3                  STORE s1, C3                 ; should be addr 03 in a 64 byte spm
 09A  0A310                  FETCH s3, (s1)               ; read data 12 back from addr 0A
 09B  1C030                  COMPARE s0, s3
 09C  360BD                  JUMP NZ, 0BD[error]
 09D  0B403                  FETCH s4, 03                 ; read data from previously masked addr C3 = 03
 09E  1C410                  COMPARE s4, s1
 09F  360BD                  JUMP NZ, 0BD[error]
 0A0  220A4                  JUMP 0A4[test_call]
 0A1                inc_s00: 
 0A1  11001                  ADD s0, 01
 0A2  01205                  LOAD s2, 05
 0A3  21207                  LOAD&RETURN s2, 07
 0A4              test_call: 
 0A4  01001                  LOAD s0, 01
 0A5  01500                  LOAD s5, 00[inc_s00'upper]
 0A6  014A1                  LOAD s4, A1[inc_s00'lower]
 0A7  24540                  CALL@ (s5, s4)
 0A8  1D002                  COMPARE s0, 02
 0A9  360BD                  JUMP NZ, 0BD[error]
 0AA  300A1                  CALL Z, 0A1[inc_s00]         ; zero flag still set
 0AB  1D003                  COMPARE s0, 03
 0AC  360BD                  JUMP NZ, 0BD[error]
 0AD  14680                  HWBUILD s6                   ; generate a carry
 0AE  3C0A1                  CALL NC, 0A1[inc_s00]
 0AF  1D003                  COMPARE s0, 03               ; carry still set, s0 should be 03
 0B0  360BD                  JUMP NZ, 0BD[error]          ; if inc was called (s0 = 04) ... it was wrong
 0B1  380A1                  CALL C, 0A1[inc_s00]         ; carry set to 0 by compare
 0B2  1D003                  COMPARE s0, 03               ; call was done ? s0 = 4 -> error
 0B3  360BD                  JUMP NZ, 0BD[error]
 0B4  01100                  LOAD s1, 00[passed'upper]
 0B5  010BE                  LOAD s0, BE[passed'lower]
 0B6  26100                  JUMP@ (s1, s0)
 0B7                test_pc: 
 0B7  1DDC9                  COMPARE sD, C9               ; random value to switch between over and underflow test
 0B8  360BB                  JUMP NZ, 0BB[test_underflow]
 0B9  200BA                  CALL 0BA[test_overflow]
 0BA          test_overflow: 
 0BA  200BA                  CALL 0BA[test_overflow]
 0BB         test_underflow: 
 0BB  01DC9                  LOAD sD, C9
 0BC  25000                  RETURN 
 0BD                  error: 
 0BD  220BD                  JUMP 0BD[error]
 0BE                 passed: 
 0BE  220BE                  JUMP 0BE[passed]
 300                         ADDRESS 300
 300                    ISR: 
 300  37001                  REGBANK B
 301  010FF                  LOAD s0, FF
 302  200A1                  CALL 0A1[inc_s00]
 303  29001                  RETURNI ENABLE


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\pgenssler\pauloBlaze\testbench\test_assembler.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   13'd         
 timestamp_minutes 09'd         
 timestamp_seconds 54'd         
 datestamp_year    15'd         
 datestamp_month   9'd          
 datestamp_day     30'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 A_port            00           test_assembler.psm
 B_port            01           test_assembler.psm
 C_port            02           test_assembler.psm
 D_port            03           test_assembler.psm
 W_port            01           test_assembler.psm
 X_port            02           test_assembler.psm
 Y_port            04           test_assembler.psm
 Z_port            08           test_assembler.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "30 Sep 2015"  
 timestamp$        "13:09:54"     



List of line labels

   Label            Addr  Source PSM File

 * start            000   test_assembler.psm
   test_star        003   test_assembler.psm
   test_add         00A   test_assembler.psm
   test_add_carry   01D   test_assembler.psm
   test_sub         029   test_assembler.psm
   test_sub_carry   032   test_assembler.psm
   test_logic       03E   test_assembler.psm
   test_shift       063   test_assembler.psm
   test_io          08A   test_assembler.psm
   test_spm         095   test_assembler.psm
   inc_s00          0A1   test_assembler.psm
   test_call        0A4   test_assembler.psm
 * test_pc          0B7   test_assembler.psm
   test_overflow    0BA   test_assembler.psm
   test_underflow   0BB   test_assembler.psm
   error            0BD   test_assembler.psm
   passed           0BE   test_assembler.psm
 * ISR              300   test_assembler.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             50
 STAR              1

 AND               3
 OR                3
 XOR               3

 ADD              11
 ADDCY             2
 SUB               4
 SUBCY             2

 TEST              -
 TESTCY            -
 COMPARE          26
 COMPARECY         -

 SL0               1
 SL1               1
 SLX               1
 SLA               1
 RL                1
 SR0               1
 SR1               1
 SRX               1
 SRA               1
 RR                1

 REGBANK           3

 INPUT             2
 OUTPUT            3
 OUTPUTK           1

 STORE             2
 FETCH             2

 DISABLE           -
 ENABLE            1
 RETURNI           1

 JUMP             53
 JUMP@             1
 CALL              6
 CALL@             1
 RETURN            1
 LOAD&RETURN       1

 HWBUILD           2



End of KCPSM6 log file.
